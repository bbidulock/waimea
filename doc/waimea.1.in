.\"
.\" Man page for Waimea
.\" 
.\" This manual page may be freely distributed and modified.
.\" Author: David Reveman <c99drn@cs.umu.se>
.\" 
.TH WAIMEA 1 "Oct 5 2002" "0.3.4" "User Manual"


.SH NAME
Waimea \- an X11 window manager designed for maximum efficiency


.SH SYNOPSIS
.B waimea 
[--display=DISPLAYNAME] [--rcfile=CONFIGFILE] 
[--stylefile=STYLEFILE] [--actionfile=ACTIONFILE] [--menufile=MENUFILE] 
[--usage] [--help] [--version]


.SH DESCRIPTION

The design goal for
.I waimea 
is to create the most efficient desktop working environment available. 
To achieve this
.I waimea
is a fast and highly customizable virtual desktop window manager.
It uses
.BR blackbox (1)
image rendering engine (blackbox styles support) and can use 
Xft library for font rendering (anti-aliased font support). 
It also features a very advanced configuration system with which
it's possible to make 
.I waimea
behave as almost any other window manager.


.SH OPTIONS
.TP
.B "--display DISPLAYNAME"
X server to contact

.TP
.B "--rcfile CONFIGFILE"
Use the alternate
.I CONFIGFILE
instead of
.IR ~/.waimearc
and
.IR @pkgdatadir@/config.

.TP
.B "--stylefile STYLEFILE"
Use the alternate
.I STYLEFILE
instead of
.IR @pkgdatadir@/styles/Default.
This overrides styleFile resource.

.TP
.B "--actionfile ACTIONFILE"
Use the alternate
.I ACTIONFILE
instead of
.IR @pkgdatadir@/actions/action.
This overrides actionFile resource.

.TP
.B "--menufile MENUFILE"
Use the alternate
.I MENUFILE
instead of
.IR @pkgdatadir@/menu
This overrides menuFile resource.

.TP
.B "--usage"
Display brief usage message

.TP
.B "--help"
Show full help message

.TP
.B "--version"
Output version information and exit


.SH "CONFIG FILE"
When starting, 
.I waimea
looks for a 
.I .waimearc 
resource file in the users home directory. If file doesn't exist, 
.I waimea
falls back to 
.I @pkgdatadir@/config, 
the system wide configuration file. To force 
.I waimea 
to read a different configuration file use 
.I --rcfile
switch. Below is a list of configuration options that 
.I waimea
understands.

.TP
.B  screenMask:     List of screen numbers
Whitespace separated list of screens that 
.I waimea 
should manage. If you for example want
.I waimea
to handle only screen .0 and screen .2, then list of screen numbers
should be: 0 2

.TP
.B scriptDir:     Dirpath
Path to alternate scripts directory
instead of
.IR @pkgdatadir@/scripts.
.I scriptDir 
is used execution of dynamic menu scripts.

.TP
.B doubleClickInterval:     Integer
Adjust the delay (in milliseconds) between mouse clicks for 
.I waimea
to consider it a double click. Default value is 
.I 300.

.P
When running  
.I waimea
on display with multiple screens the screen0 key in the following 
configuration options can also be screen1, 2 etc. for any appropriate screen.

.TP
.B  screen0.styleFile:     Filepath
Path to alternate
.I STYLEFILE
instead of
.I @pkgdatadir@/styles/Default.

.TP
.B  screen0.menuFile:     Filepath
Path to alternate
.I MENUFILE
instead of
.I @pkgdatadir@/menu.

.TP
.B screen0.actionFile:     Filepath
Path to alternate
.I ACTIONFILE
instead of
.IR @pkgdatadir@/actions/action.
	
.TP
.B screen0.colorsPerChannel:     Integer
This tells 
.I waimea
how many colors to take from the X
server on pseudocolor displays. A channel would be red,
green, or blue. 
.I Waimea 
will allocate this variable ^ 3 colors and make them always available.
Value must be between 2 and 6. When you run 
.I waimea 
on an 8-bit display, you must set this resource to 4. 
Default value is 
.I 4.

.TP
.B  screen0.cacheMax:     Integer
This tells 
.I waimea 
how much memory (in KB) it may use to store cached pixmaps on the X server.
If your machine runs short of memory, you may lower this value. 
Default value is 
.I 200.

.TP
.B  screen0.imageDither:     Boolean
Tells 
.I waimea
to dither images on none TrueColor screens. Default value is 
.I True.

.TP
.B screen0.virtualSize:     IntegerxInteger
Tells 
.I waimea 
what virtual desktop size to use. Example:
.I 3x3
will set the virtual desktop size to three times screen height 
in virtual height and three times screen width in virtual width.
Default value is 
.I 3x3.

.TP
.B screen0.menuStacking:     StackingType
Tells 
.I waimea 
what stacking type to use for menus. Can be one of: AlwaysOnTop, 
AlwaysAtBottom or Normal.
Default type is
.I Normal.

.TP
.B screen0.transientAbove:     Bool
Tells 
.I waimea 
to use special handling of transient windows. When turned on 
.I waimea 
will always keep transient windows above and focused relative to the
the 'transient for' window.
Default value is
.I True.

.PP
Dockappholder Resources
.PP
It is possible to have more than one dockappholder running.
First dockappholder should be named 
.I dock0
and the second 
.I dock1
and so on. One dockappholder is always running whether you have a
.I dock0
line in your 
.I CONFIGFILE  
or not.

.TP
.B screen0.dock[num].geometry:     OffsetString
Define dockappholder position, X offset string of form:
[{+-}<xoffset>{+-}<yoffset>]. See 
.BR X(1).

.TP
.B screen0.dock[num].order:     Regular Expression List
A whitespace separated list of regular expressions describing how 
to order the dockapps in the dockappholder. Dockapps can be 
ordered by window name, window class and window title. For window 
name use 
.I "n/Regexp/" 
, `Regexp' being the POSIX regular expression used for window name
matching. For window class use 
.I "c/Regexp/"
, `Regexp' being the POSIX regular expression used for window class
matching. For window title use 
.I "t/Regexp/"
, `Regexp' being the POSIX regular expression used for window title
matching.

Example:

screen0.dock0.order:    n/.*meter$/ c/pager/

This will put dockapp window with name ending with `meter' at 
the first position in dockappholder and dockapp with classname containing
`pager' at second position. All dockapp windows that doesn't match any 
regular expression will be put in dock0 at last position.

.TP
.B screen0.dock[num].direction:     Direction
Dockappholder direction {Vertical, Horizontal}

.TP
.B screen0.dock[num].centered:     Boolean
True if you want the dockappholder to be centered. If
direction is Vertical, yoffset from geometry resource will
be ignored and dockappholder will be centered vertically.
If direction is Horizontal, xoffset from geometry resource
will be ignored and dockappholder will be centered
horizontally.

.TP
.B screen0.dock[num].gridSpace:     Integer
Number of pixels spacing between dockapps in dockappholder.

.TP
.B screen0.dock[num].stacking:     StackingType
Stacking order for dockappholder {AlwaysOnTop, AlwaysAtBottom}.

.TP
.B screen0.dock[num].inworkspace:     Boolean
True if you don't wont dockappholder to alter the workarea. Maximizied windows
will be maximized over the dockappholder when this is set to true. Default
is False.


.SH STYLES
.I Waimea 
enables you to use 
.I blackbox 
specialized style files that contain 
.BR X(1)
resources to specify colors, textures and fonts, and thus the 
overall look of your window decorations and menus. 
However there are a few keys in 
.I blackbox 
styles that 
.I waimea
doesn't use and there are a few new keys that doesn't exist in standard
.I blackbox 
styles. 
.PP
To understand how the style mechanism works, you should have a little 
knowledge of how X resources work. See 
.BR X(1) 
for this.
.PP
.I Waimea 
allows you to configure the style of menus and the windows.
Dockappholders uses the same style as the windows.
.PP 
Here are the different types of values:
.TP
.B Color
Is a color name. See
.BR X(1)
for how to write valid color names. 
e.g.: 'green'.
.TP
.B Font
XLFD (X core font) or Xft font name. Xft font names must be followed by [xft] 
suffix. See
.BR X(1)
for how to write valid XLFD font names.
.br
e.g.:
.nf

-adobe-courier-medium-r-normal--10-100-75-75-m-60-iso8859-1

.fi
The format for Xft font names is:
.nf

<family>-<size>:<name>=<value> [xft]
.fi

An arbitrary set of additional elements can be appended to the Xft font name,
the complete list of possible properties is:

.nf
Name            Type
---------------------------------
family          String
style           String
slant           Int
weight          Int
size            Double
aspect          Double (only in Xft2)
pixelsize       Double
encoding        String (only in Xft1)
spacing         Int
foundry         String
core            Bool (only in Xft1)
antialias       Bool
xlfd            String (only in Xft1)
file            String
index           Int
rasterizer      String
outline         Bool
scalable        Bool
rgba            Int

(Defaults from resources)

scale           Double
render          Bool (only in Xft1)
minspace        Bool

(Specific to FreeType rasterizer)

charwidth       Int
charheight      Int
matrix          XftMatrix
charset         CharSet (only in Xft2)
lang            String (only in Xft2)
.fi

As family and size are both nearly always needed to access a Xft font, they're
given a privileged place, but really they're no different than the
remaining values.  For elements that use an enumerated list of possible
values, the values are given names which can be used in place of an integer,
or can actually replace the whole name=value part.  They're all unique,
so this actually works.  Here's a list of all of the enumerated values and
the associated name:

.nf
Value           Element
---------------------------------
light           weight
medium          weight
demibold        weight
bold            weight
black           weight

roman           slant
italic          slant
oblique         slant

proportional    spacing
mono            spacing
charcell        spacing

rgb             rgba
bgr             rgba
vrgb            rgba
vbgr            rgba
.fi

Some example Xft font names:
.nf

times-12 [xft]

.fi
12 point times
.nf

times,charter-12:bold [xft]

.fi
12 point, preferring 'times', but accepting 'charter', bold.
.nf

times-12:bold:slant=italic,oblique [xft]

.fi
12 point times bold, either italic or oblique
.nf

times-12:rgba=vbgr [xft]

.fi
12 point times, optimized for display on an LCD screen with sub-pixel
elements arranged vertically with blue on the top and red on the bottom.
.nf

times:pixelsize=100 [xft]

.fi
100 pixel times -- pixel size overrides any point size

.TP
.B Xft opacity level
Xft font opacity level. Integer value from 0 to 100, where 0 is the default 
non translucent opacity level and and 100 makes it a fully transparent font.

.TP
.B Font justification
Is one of left, right or center. 
e.g.: 'left'.

.TP
.B Texture descriptions
Texture descriptions are specified directly to the key that they
should apply to, e.g.:
.nf
 
window.label:  Raised Gradient Diagonal Bevel1

.fi
A texture description consists of up to five fields, which are as follows:
.nf
 
.I Flat / Raised / Sunken
.fi
gives the component either a flat, raised or sunken appearance.
.nf 

.I Gradient / Solid / Pixmap
.fi
tells 
.I waimea 
to draw either a solid color or a gradiented texture.
.nf

.fi
.I Horizontal / Vertical / Diagonal / Crossdiagonal / Pipecross / Elliptic / Rectangle / Pyramid
.nf
.fi
Select one of these texture types. They only work when also
.I Gradient
is specified!
.nf

.fi
.I Tiled / Scaled / Stretched
.nf
.fi
Select one of these resizing methods. They only work when also
.I Pixmap
is specified!. Tiled resizing does not resize the image just tiles it, 
fastest method. Scaled resizing performs a normal scaling of image, all parts
of the image are scaled equally. Stretched resizing only scales the middle
part of the image, all borders are preserved.
.nf
 
.I Interlaced
.fi
tells 
.I waimea 
to interlace the texture (darken every other line).
This option is most commonly used with gradiented textures, but it 
also works in solid textures.
.nf
 
.I Bevel1 / Bevel2
.fi
tells 
.I waimea 
which type of bevel to use.
Bevel1 is the default bevel.
The shading is placed on the edge of the image.
Bevel2 is an alternative.
The shading is placed one pixel in from the edge of the image.

Instead of a texture description, also the option
.I ParentRelative
is available, which makes the component appear as a part of its parent,
totally transparant.
.nf

.fi
All gradiented textures are composed of two color values: the
.IR color " and " colorTo " resources."
When
.I Interlaced
is used in
.I Solid
mode, the
.I colorTo
resource is used to find the interlacing color.

.fi
A image file must be specified for all pixmap textures.
.IR pixmap 
resources is used for finding the image file. Must be either a complete
file path, a file path relative to 
.I waimea 
start directory or an image file
in the same directory as the style file.

.TP
.B Texture opacity level
Texture opacity level. Integer value from 0 to 100, where 0 is the default 
non translucent opacity level and and 100 makes it a fully transparent texture.
This requires that the program setting the background image has support for
setting _XROOTPMAP_ID property on root window. Esetroot does this.
Opacity works for all types of textures even pixmaps.

.TP
.B Pixmap stretching borders
Borders used for pixmap stretching. Format is { LEFT, RIGHT, TOP, BOTTOM }
LEFT being the width of left border, RIGHT being the width of right border,
TOP being the height of top border and BOTTOM being the height of bottom
border. Only graphics not within any of the borders will be scaled when
stretching pixmap.

.PP
Here are the keys 
.I waimea 
understands together with the kind of value they can contain. 

.PP
.I Window Keys
.br
Controls the look of the window decorations. The '*' in the window keys can 
be one of: 
.I title, label, handle, button
or 
.I grip.

.PP
.B window.*.focus:     Texture description
.br
.B window.*.focus.opacity:     Texture opacity level
.br
.B window.*.focus.color:     Color
.br
.B window.*.focus.colorTo:     Color
.br
.B window.*.focus.pixmap:     Pixmap
.br
.B window.*.focus.border:     Border
.RS
Texture type, opacity level, colors and pixmap used for focused window textures.
.RE

.PP
.B window.*.unfocus:     Texture description
.br
.B window.*.unfocus.opacity:     Texture opacity level
.br
.B window.*.unfocus.color:     Color
.br
.B window.*.unfocus.colorTo:     Color
.br
.B window.*.unfocus.pixmap:     Pixmap
.br
.B window.*.unfocus.border:     Border
.RS
Texture type, opacity level and colors used for unfocused window textures.
.RE

.PP
.B window.label.focus.textColor:     Color
.br
.B window.label.focus.textColor.opacity:     Xft opacity level
.RS
Color and opacity level used for focused window label font.
.RE

.PP
.B window.label.unfocus.textColor:     Color
.br
.B window.label.unfocus.textColor.opacity:     Xft opacity level
.RS
Color and opacity level used for unfocused window label font.
.RE

.PP
.TP 
.B window.button.focus.picColor:    Color
Color used for focused window button symbols.

.PP
.TP 
.B window.button.unfocus.picColor:    Color
Color used for unfocused window button symbols.

.PP
.TP 
.B window.button.pressed.picColor:    Color
Color used for pressed button symbols.

.PP
.TP 
.B window.justify:     Font justification
Font justification for window labels.

.PP
.TP
.B window.font:     Font
Font for window titles.

.PP
.TP 
.B borderWidth:     Integer
Integer value for window border width.

.PP
.TP 
.B borderColor:     Color
Color of window border.

.PP
.TP 
.B outlineColor:     Color
Color of window outline used for non-opaque moving and resizing.

.PP
.TP 
.B window.title.height:    Integer
Integer value for forced titlebar height. If key isn't defined the title
height is set by the height of the font.


.PP
.I Menu Keys
.br
Controls the look of the menus. The '*' in the menu keys can be 
one of:
.I title, frame
or 
.I hilite.

.PP
.B menu.*:     Texture description
.br
.B menu.*.opacity:     Texture opacity level
.br
.B menu.*.color:     Color 
.br
.B menu.*.colorTo:     Color
.br
.B menu.*.pixmap:     Pixmap
.br
.B menu.*.border:     Border
.RS
Texture type, opacity level and colors used for menu textures.
.RE

.PP
.B menu.*.textColor:     Color
.br
.B menu.*.textColor.opacity:     Xft opacity level
.RS
Color and opacity level used for menu fonts.
.RE

.PP
.TP 
.B menu.*.justify:     Font justification
Font justification for menu items.

.PP
.TP
.B menu.*.font:     Font 
Font for menu items.

.PP
.TP 
.B menu.bullet.look:	String or 'char'
String or character code used for menu bullets.

.PP
.TP 
.B menu.checkbox.true.look:	String or 'char'
String or character code used for true checkboxes.

.PP
.TP 
.B menu.checkbox.false.look:	String or 'char'
String or character code used for false checkboxes.

.PP
.TP 
.B menu.borderWidth:     Integer
Integer value for menu border width.

.PP
.TP 
.B menu.item.height:    Integer
Integer value for forced menu frame item height. If key isn't defined the 
frame menu item height is set by the height of the font.

.PP
.TP 
.B menu.title.height:    Integer
Integer value for forced menu title item height. If key isn't defined the 
frame menu title height is set by the height of the font.


.PP
.I Dockappholder Keys
.br
Controls the look of the dockappholders. A different texture can be assigned 
to each dockappholder. '[ID]' should be replaced by a dockappholder ID number.
A dockappholder ID is >=0 and depends on the dockappholder configuration in 
the rc-file.

.PP
.B dockappholder.dock[ID].frame:     Texture description
.br
.B dockappholder.dock[ID].frame.opacity:     Opacity level
.br
.B dockappholder.dock[ID].frame.color:     Color
.br
.B dockappholder.dock[ID].frame.colorTo:     Color
.br
.B dockappholder.dock[ID].frame.pixmap:     Pixmap
.br
.B dockappholder.dock[ID].frame.border:     Border
.RS
Texture type, opacity level and colors used for dockappholder 'dock[ID]'s frame 
texture.
.RE

.PP
.TP 
.B dockappholder.dock[ID].borderWidth:     Integer
Border width used for dockappholder 'dock[ID]'s border.

.PP
.TP 
.B dockappholder.dock[ID].borderColor:     Color
Border color used for dockappholder 'dock[ID]'s border.


.PP
.I Button Keys
.br
Controls the look of the titlebar buttons. For backwards compatibility with 
blackbox styles 
.I waimea 
still understands the above mentioned window.button.* key, but 
.I waimea
have a much more advanced configuration system for titlebar buttons. The 
. waimea 
titlebar configuration system allows you to have any number of titlebar buttons
and the position and look for each button can be specified.
.PP
A titlebar button works just like a checkbox. It has two states, a 'false' 
state and a 'true' state. Which state the button is in depends on a variable 
and the look of each of these states can be specified. The '[ID]' must be a 
number >= 0. For
.I waimea 
to read button configuration with an ID of 2, there must be a 
configuration with an ID of 0 and an ID of 1, this is because
.I waimea 
stops reading button configurations when it comes to missing ID.

.PP
.TP 
.B window.button[ID].foreground:     Boolean
True if you want waimea to draw its standard foreground graphics on the button.
Graphics drawn depends on the buttons state configuration.

.PP
.TP 
.B window.button[ID].state:     Checkbox State
This specifies what variable the button should monitor for its state. Can be 
one of these:
.br
MAXIMIZED
.br
SHADED
.br
STICKY
.br
ALWAYSONTOP
.br
ALWAYSATBOTTOM
.br
DECORTITLE
.br
DECORHANDLE
.br
DECORBORDER
.br
DECORALL
.br
None
.br

When set to None, titlebar button will only have one state (false state).
Default is None.

.PP
.TP 
.B window.button[ID].autoplace:     Autoplace Type
This specifies the autoplace type for the button. Can be one of Left, Right
or False. Left will automatically place the button on the left side of the 
titlebar so that it doesn't cover any other button and Right will automatically
place the button on the right side. No automatic placement will be used when
set to False. Default is False.

.PP
.TP 
.B window.button[ID].position:     Offset
X coordinate for button. If offset is positive, then the left side of the 
titlebar will be used as X coordinate zero. If offset is negative, then the
right side of the titlebar will be used as X coordinate zero. 'position' 
resource will be ignored if not 'autoplace' resource is set to False.

.PP
.B window.button[ID].[STATE].focus:     Texture description
.br
.B window.button[ID].[STATE].focus.opacity:     Opacity level
.br
.B window.button[ID].[STATE].focus.color:     Color
.br
.B window.button[ID].[STATE].focus.colorTo:     Color
.br
.B window.button[ID].[STATE].focus.pixmap:     Pixmap
.br
.B window.button[ID].[STATE].focus.border:     Border
.br
.B window.button[ID].[STATE].unfocus:     Texture description
.br
.B window.button[ID].[STATE].unfocus.opacity:     Opacity level
.br
.B window.button[ID].[STATE].unfocus.color:     Color
.br
.B window.button[ID].[STATE].unfocus.colorTo:     Color
.br
.B window.button[ID].[STATE].focus.border:     Border
.br
.B window.button[ID].[STATE].unfocus.pixmap:     Pixmap
.br
.B window.button[ID].[STATE].pressed:     Texture description
.br
.B window.button[ID].[STATE].pressed.opacity:     Opacity level
.br
.B window.button[ID].[STATE].pressed.color:     Color
.br
.B window.button[ID].[STATE].pressed.colorTo:     Color
.br
.B window.button[ID].[STATE].pressed.pixmap:     Pixmap
.br
.B window.button[ID].[STATE].pressed.border:     Border
.RS
Texture type, opacity level and colors used for titlebar button[ID]. [STATE]
can be 'false' or 'true'. If button have more than one state then both 'false'
and 'true' state textures should be specified. If button have only one
state then only 'false' state needs to be specified.
.RE

.PP
.TP 
.B rootCommand:     Command line
This command is executed whenever this style is loaded.
Typically it sets the root window to a nice picture.

.PP
Default style file is @pkgdatadir@/styles/Default.
You can study or edit this style to grasp how the style mechanism works.


.SH ACTIONS
.I Waimea 
uses special action files for controlling its behavior.
The idea is that you could specify an 
.I action 
for every useful X event received.
.PP
An action file should contain action lists for different types of windows.
An action list looks like this:
.nf

WINDOW {
   ACTIONLINE,
   ACTIONLINE
}
.fi
.PP
WINDOW is a window that you can create actions for, a list of windows that you
can assign actions for follows below. ACTIONLINE is a string describing the
action to be performed and when. Actions are matched in the same order as
the order of the action lines.
.PP
For convenience it's also possible to define lists of action lines. e.g.:
.nf

DEF definedTitleActions {
    StartMove     : ButtonPress = Button1,
    EndMoveResize : ButtonRelease = Button1
}
window.title {
   definedTitleActions,
   ToggleShade : DoubleClick = Button1
}

.fi
In window.title action list 'definedTitleActions' will be replaced by
the action lines defined above.
.PP 
An action line should start with an action and then a ':' character
followed by an event description.
.PP
The event description contains an event type, an optional event detail and 
a modifier mask.
.PP
Here are two good examples:
.nf

StartMove   : ButtonPress = Button1 & Mod1Mask & ControlMask
StartResize : ButtonPress = Button1 & Mod1Mask & !ControlMask

.fi
The first line will create a startmove 
.I action 
that will be performed when
a ButtonPress event is received from Button1 and at least mod1 
modifier and control modifier are active. The second line will
create a startresize 
.I action 
that will be performed when a ButtonPress
event is received from Button1 and at least mod1 modifier is active
and the control modifier is not active.

.PP 
.I Waimea
also supports delayed actions. A delay is defined within brackets at the
end of the action line. A delay definition consists of a delay time in 
milliseconds followed by an optional delay break event list. The delay 
break list is a list of events that if occurring during the delay time will
discard the action. The delay time and the delay break list are separated 
with a colon and the events in the delay break list are separated with
pipe signs. e.g.:
.nf

Raise : EnterNotify [2000 : LeaveNotify | ButtonPress]

.fi
Adds a 2000 milliseconds delay to the Raise action, LeaveNotify and 
ButtonPress events will discard the action.

.PP
Here is the list of all windows that you can create actions for
(to define individual actions for a specific window just replace 'window.*'
with n/Regexp/.*, c/Regexp/.* or t/Regexp/.* where Regexp is the regular
expression to match window name/class/title):
.TP
.B window.frame
This is the parent window for the client window and all decoration
windows. Use this key if you want to set an 
.I action 
for the window border.
.PP
.TP
.B window.title
This is the parent window for the label and button windows. You probably
want this window to have the same action list as the label window.
.PP
.TP
.B window.label
This is the window that holds the titlebar text.

.PP
.B window.clientactive
.br
.B window.clientpassive
.RS
This is the actual window created by the client.
.I window.clientactive
is the action list for active (focused) windows and
.I window.clientpassive
is the action list for passive (unfocused) windows.
All actions for window.client.* can be prefixed with a '*' character
to make them pass-through actions (Events matching pass-through actions
will also be sent to the client window).
.RE

.PP
.B window.button[ID]
.RS
Titlebar button window, [ID] will match with [ID] from style file.
.RE

.PP
.TP
.B window.handle
This is the window for the middle part of the handlebar.

.PP
.B window.leftgrip
.br
.B window.rightgrip
.RS
Windows for the left and right grip in the handlebar.
.RE

.PP
.B menu.title
.br
.B menu.item
.br
.B menu.sub
.br
.B menu.checkbox
.RS
Menu item windows.
.RE

.PP
.TP
.B root
Root window (background).
.PP
.B westedge
.br
.B eastedge
.br
.B northedge
.br
.B southedge
.RS
Transparent windows at the edges of the screen. Useful for viewport
shifting.
.RE

.PP
Here is the list of actions common for all window types:

.PP
.TP
.B {command line}
You can specify a command line to execute instead of
a function. Command line must be within a '{'
and a '}' character. All special characters need to be 
escaped (with a `\\') to protect them from expansion. 
Special characters are:
.nf
( ) { } < > [ ] " $

.fi

.PP
.TP
.B focus
Set input focus to the event window.

.PP
.B viewportleft
.br
.B viewportright
.br
.B viewportup
.br
.B viewportdown
.RS
Moves viewport one screen width and warps the pointer one screen width
in the opposite direction.
.RE

.PP
.TP
.B viewportrelativemove(OffsetString)
Moves viewport relative to its current position. MUST have an X offset 
string as parameter:
[{+-}<xoffset>{+-}<yoffset>] See
.BR X(1).
The xoffset and yoffset values defines the number of pixels to move the
viewport. A 'W' character in the OffsetString is replaced with 
screenwidth. A 'H' character in the OffsetString is replace with 
screenheight.

.PP
.TP
.B viewportfixedmove(OffsetString)
Moves viewport to a fixed position. MUST have an X offset 
string as parameter:
[{+-}<xoffset>{+-}<yoffset>] See 
.BR X(1).
The xoffset and yoffset values defines the new viewport position.
{+-} signs defines viewport gravity. A 'W' character in the OffsetString
is replaced with screenwidth. A 'H' character in the OffsetString is 
replace with screenheight.

.PP
.TP
.B startviewportmove
Moves viewport after mouse motion events, kind of
the same way as you move windows. Must be ended with 
.B endmoveresize 
action.

.PP
.TP
.B taskswitcher
Maps windowlist menu at the middle of the screen. This menu is very
useful for switching between windows.

.PP
.TP
.B nexttask
Sets focus to the window that was focused longest time ago. 

.PP
.TP
.B previoustask
Sets focus to the window that was focused before the currently focused
window.

.PP
.TP 
.B pointerrelativewarp(OffsetString)
Warps pointer relative to its current position. MUST have an X offset
string as parameter:
[{+-}<xoffset>{+-}<yoffset>] See
.BR X(1).
The xoffset and yoffset values defines the number of pixels to warp the
pointer.

.PP
.TP
.B pointerfixedmove(OffsetString)
Warp pointer to a fixed position. MUST have an X offset
string as parameter:
[{+-}<xoffset>{+-}<yoffset>] See  
.BR X(1).
The xoffset and yoffset values defines the new pointer position.
{+-} signs defines pointer gravity.

.PP
.TP
.B nop
Does nothing. But will when used as non-pass-through action on client 
window grab the event from the client.


.PP
Here is the list of additional actions for window.* windows:

.PP
.TP
.B raise
Raise window to top of display stack.

.PP
.TP
.B raisefocus
Raise window to top of display stack and focus it.

.PP
.TP
.B lower
Lower window to bottom of display stack.

.PP
.B startmove
.br
.B startopaquemove
.RS
Move window by dragging the mouse. startmove
.I action
will display a window outline while dragging the mouse and first move the
actual window when you're finished dragging. startopaquemove
.I action
will move the actual window while you're dragging the mouse. Both must be 
ended with 
.B endmoveresize 
action.
.RE

.PP
.B startresizeright
.br
.B startresizeleft
.br
.B startopaqueresizeright
.br
.B startopaqueresizeleft
.RS
Resize window by dragging the mouse.
.I Actions 
not containing 'opaque' will display a window outline while dragging
the mouse and first move the actual window when you're finished
dragging.
.I Actions 
ending with 'opaque' will resize the actual window while
you're dragging the mouse. All four must be 
ended with 
.B endmoveresize 
action.
.RE

.PP
.TP
.B endmoveresize
Ends a move or resize process.

.PP
.TP
.B close
Sends a delete message to the client window. A normal running X window
should accept this event and destroy itself.

.PP
.TP
.B kill
Tells the the X server to remove the window from the screen through
killing the process that created it.

.PP
.TP
.B closekill
Checks if the window will accept a delete message. If it will, then we
send a delete message to the client window otherwise we tell the
X server to kill the client that created it.

.PP
.B menumap(menu_name)
.br
.B menuremap(menu_name)
.br
.B menuunmap(menu_name)
.br
.B menumapfocused(menu_name)
.br
.B menuremapfocused(menu_name)
.br
.B menuunmapfocused(menu_name)
.RS
Map, remap or unmap a menu. Mapping a menu that is already mapped
will do nothing. Remapping a menu that is already mapped will move the 
mapped menu to the new mapping position.
.I Actions 
ending with 'focused' will set input focus to the first
focusable menu item in the menu when being mapped.
A menu must be given as parameter to all these 
.I actions.
Menu can be a dynamic menu.
.RE

.PP
.B shade
.br
.B unshade
.br
.B toggleshade
.RS
shade 
.I action
will put window in shaded state. unshade 
.I action 
will restore window from shaded to normal state. toggleshade 
.I action 
will toggle between shaded and normal state.
In shaded state only the titlebar for the window is shown.
.RE

.PP
.B maximize
.br
.B unmaximize
.br
.B togglemaximize
.RS
maximize 
.I action
will put window in maximized state. unmaximize 
.I action 
will restore window from maximized to normal state. togglemaximize 
.I action 
will toggle between maximized and normal state.
In maximized state the window will have maximum allowed size fitted 
in screen.
.RE

.PP
.B sticky
.br
.B unsticky
.br
.B togglesticky
.RS
sticky
.I action
will put window in sticky state. unsticky
.I action 
will restore window from sticky to normal state. togglesticky
.I action 
will toggle between sticky and normal state.
In sticky state the window will stick to its position whatever the viewport 
is. 
.RE

.PP
.B decortitleon
.br
.B decortitleoff
.br
.B decortitletoggle
.RS
Turn on, off or toggle the window titlebar decoration.
.RE

.PP
.B decorhandleon
.br
.B decorhandleoff
.br
.B decorhandletoggle
.RS
Turn on, off or toggle the window handlebar decoration.
.RE

.PP
.B decorborderon
.br
.B decorborderoff
.br
.B decorbordertoggle
.RS
Turn on, off or toggle the window border decoration.
.RE

.PP
.B decorallon
.br
.B decoralloff
.RS
Turn on or off all window decorations.
.RE

.PP
.B alwaysontopon
.br
.B alwaysontopoff
.br
.B alwaysontoptoggle
.RS
Turn on, off or toggle if window should be always on top. Always on top 
windows are always at the top of the display stack.
.RE

.PP
.B alwaysatbottomon
.br
.B alwaysatbottomoff
.br
.B alwaysatbottomtoggle
.RS
Turn on, off or toggle if window should be always at bottom. Always at
bottom windows are always at the bottom of the display stack.
.RE

.PP
.B acceptconfigrequeston
.br
.B acceptconfigrequestoff
.br
.B acceptconfigrequesttoggle
.RS
Turn on, off or toggle if window should handle received configure request 
events.
.RE

.PP
.B moveresize(X11 geometry string)
.br
.B moveresizevirtual(X11 geometry string)
.RS
MUST have an X11 geometry string as parameter:
[<width>{xX}<height>][{+-}<xoffset>{+-}<yoffset>] See
.BR X(1).
Sets window geometry. moveresize action moves window to a actual screen 
position. moveresizevirtual action moves window to a virtual screen
position. A 'W' character in the OffsetString is replaced with
screenwidth. A 'H' character in the OffsetString is replace with
screenheight.

.RE

.PP
.TP
.B movetopointer
Moves center of window to mouse pointer position.

.PP
Here is the list of additional actions for menu.* windows:

.PP
.TP
.B raise
Raise menu to top of display stack.

.PP
.TP
.B lower
Lower menu to bottom of display stack.

.PP
.B startmove
.br
.B startopaquemove
.RS
Move menu by dragging the mouse. startmove
.I action
will display a menu outline while dragging the mouse and first move the
actual menu when you're finished dragging. startopaquemove
.I action
will move the actual menu while you're dragging the mouse. Both must be 
ended with 
.B endmoveresize 
action.
.RE

.PP
.TP
.B endmoveresize
Ends a move or resize process.

.PP
.B mapsub
.br
.B mapsubonly
.br
.B remapsub
.br
.B mapsubfocused
.br
.B mapsubfocusedonly
.br
.B remapsubfocused
.br
.B unmap
.br
.B unmapfocused
.RS
Map, remap or unmap menu items submenu. If menu item doesn't 
have a submenu, nothing is done. Mapping a submenu that is 
already mapped will do nothing. 
Remapping a submenu that is already mapped will move the 
mapped submenu to the new mapping position.
.I Actions 
ending with 'focused' will set input focus to the first
focusable window in the submenu when being mapped.
.I Actions 
ending with 'only' will unmap all other submenus before mapping submenu.
.RE

.PP
.TP
.B unmapsubs
Unmaps the submenutree of the menu that contains the menu item. 
Only linked menus are part of the submenutree and will be unmapped by 
this action.

.PP
.TP
.B unmaptree
Unmaps the complete menutree that the menu containing the menu item 
is part of. Only linked menus are part of the menutree and will be 
unmapped by this action.

.PP
.TP
.B func
Calls function linked to menu item. If menu item doesn't 
have a linked function, nothing is done.

.PP
.TP
.B exec
Executes command line linked to menu item. If menu item doesn't 
have a linked command line, nothing is done.

.PP
.TP
.B unlink
unlinks menu containing the menu item from its menu tree.


.PP
Here is the list of additional actions for root, *edge windows:

.PP
.B menumap(menu_name)
.br
.B menuremap(menu_name)
.br
.B menuunmap(menu_name)
.br
.B menumapfocused(menu_name)
.br
.B menuremapfocused(menu_name)
.br
.B menuunmapfocused(menu_name)
.RS
Map, remap or unmap a menu. Mapping a menu that is already mapped
will do nothing. Remapping a menu that is already mapped will move the 
mapped menu to the new mapping position.
.I Actions 
ending with 'focused' will set input focus to the first
focusable menu item in the menu when being mapped.
A menu must be given as parameter to all these 
.I actions.
.RE

.PP
.TP
.B exit
Shutdowns waimea.

.PP
.TP
.B restart[(command line)]
Shutdowns waimea and executes command line parameter. If no command line
parameter was given this 
.I action
executes the same command line as waimea was started with.

.PP
Here is the list of event types that can be linked to an 
.I action:

.PP
.TP
.B buttonpress
Occurs when a mouse button is pressed.
Event detail for this event can be one of 
.I button1, button2, button3, button4, button5, button6, button7 or anybutton.

.PP
.TP
.B buttonrelease
Occurs when a mouse button is released.
Event detail for this event can be one of 
.I button1, button2, button3, button4, button5, button6, button7 or anybutton.

.PP
.TP
.B doubleclick
Occurs when a mouse button is pressed two times within time of the 
double click interval.
Event detail for this event can be one of 
.I button1, button2, button3, button4, button5, button6, button7 or anybutton.

.PP
.TP
.B keypress
Occurs when a key is pressed.
Event detail for this event should be standard KeySym name obtained 
from <X11/keysymdef.h> by removing the XK_ prefix from each name or 
.I anykey.

.PP
.TP
.B keyrelease
Occurs when a key is released.
Event detail for this event should be standard KeySym name obtained 
from <X11/keysymdef.h> by removing the XK_ prefix from each name or 
.I anykey.


.PP
.TP
.B enternotify
Occurs when mouse enters a window.
No event details for this event type.

.PP
.TP
.B leavenotify
Occurs when mouse leaves a window.
No event details for this event type.

.PP
.TP
.B maprequest
Occurs when a window requests to be mapped.
No event details for this event type.


.PP
Here is the list of event modifiers that can used in the modifier mask:

.PP
.B shiftmask
.br
.B lockmask
.br
.B controlmask
.br
.B mod[1-5]mask
.br
.B button[1-5]mask
.br
.B moveresizemask

.PP
Default action file is @pkgdatadir@/actions/action.
You can study or edit this action file to grasp how the action system works.


.SH MENUS

All menus used in the action file must be defined in the menu file.
.PP
A menu definition starts with a [start] tag and ends
with an [end] tag. Between the [start] and the [end] tag a number of 
[item], [title], [sub] and [checkbox] tags should be placed.
The looks and action lists are the only things separating the first three 
menu item types. All three of these tags could be
followed by a (string), "string", {string} and <string>.
A [checkbox] tag is basically an [item] tag with two states.

.PP
.I Waimea
menu system is compatible with
.I blackbox(1)
menu system so higher level tags as [begin], [exec], [submenu], 
[nop], [restart] and [exit] are supported. 
.I blackbox(1) 
also support [styledir], [reconfig] and [config] tags, these tags are 
not supported by
.I Waimea.

.PP
() = menu item title
.br
"" = action
.br
{} = command line
.br
<> = sub menu
.PP

e.g.:
.nf

[start]   (menu)
  [title] (Menu)
  [item]  (Xterm)    {xterm}
  [sub]   (Programs) <progs>
  [item]  (Restart)  "restart"
  [item]  (Exit)     "exit"
[end]

.fi
It is possible to start defining a new menu within another menu.
e.g.:
.nf

[start]    (menu)
  [start]  (menu2)
    [item] (not smart)    {rm -rf ~/.}
    [end]  
  [sub]    <menu2>
[end]

.fi

.PP
[include] tags can be used anywhere in a menu file to include
the contains of another file. e.g.:
.nf

[include] (/home/user/.waimea/rootmenu)

.fi


.B Environment Variables And Window Info Expansion
.br
Menu item titles include filenames and submenu references can 
contain environment variables. e.g.:
.nf
[item] (Logout $USER) "exit"
.fi
$USER will be replaced with USER environment variable. 
.PP
Menu mapped by event occurring on a window.* window can contain
special window info character sequences. These character sequences
are expanded with the current window info when menu is mapped. e.g.:
.nf

[item] (win name: \\n)

.fi
Will be expanded to:
.nf

[item] (win name: windowname)

.fi
Where windowname is the actual class name of the window.
.br
These are the character sequences that
.I waimea 
recognizes:
.nf

"\\c" Window class
"\\n" Window class name
"\\h" Host name for window owner
"\\p" PID of window owner

.fi
If some window info isn't known for a window, the character sequence
used for expanding this info will be replaced with an empty string.
.PP
All special characters need to be escaped (with a `\\') to protect 
them from expansion. Special characters are:
.nf
( ) { } < > [ ] " $ 

.fi

.PP
.B Checkboxes
.br
A checkbox item is a item that have two states and a flag decides which
state the item is in. e.g.:
.nf

[checkbox=STICKY] @FALSE (Sticky) "sticky" @TRUE (Sticky) "unsticky"

.fi
Flag to decide which mode to be in for this checkbox is STICKY (the
sticky flag for a window). If STICKY flag is 'False' the checkbox item
will be in mode defined by menu string after @FALSE and if STICKY flag
is 'True' the checkbox item will be in mode defined by the menu string
after @TRUE.

.PP
Here is the list of flags that can be used with checkbox items:
.br
MAXIMIZED
.br
SHADED
.br
STICKY
.br
ALWAYSONTOP
.br
ALWAYSATBOTTOM
.br
DECORTITLE
.br
DECORHANDLE
.br
DECORBORDER
.br
DECORALL
.br
.PP

.PP
.B Taskswitcher
.br
Predefined menu named "__windowlist__" can be used in menu file
and action file to access the taskswitcher menu.

.PP
.B Dynamic menus
.br
Waimea supports dynamic menus. A Dynamic menu is a menu that is 
generated when mapped. Compared to a normal static menu that must be fully
defined in the 
.I MENUFILE
the definition of a dynamic menu only consists of a command line. 
The command line is executed when the menu is to be mapped and the 
standard output from the command is parsed in the same way as the
.I MENUFILE
to generate the dynamic menu. Every time the menu is remapped the command
line is executed and a new menu is generated. A dynamic menu is defined 
as a submenu link in the
.I MENUFILE
or as a menu_name parameter to one of the 
.I menumap 
actions. A dynamic menu definition must start with a '!' character and be
followed by a command line. e.g.:
.nf

[sub] (Styles) <!styledir.pl>

.fi
Creates a submenu item with title 'Styles' and the submenu for the item 
is dynamic menu created by execution of styledir.pl script. Dynamic 
menus can contain definitions of other dynamic menus.

.PP
Default menu file is @pkgdatadir@/menu.
You can study or edit this menu file to grasp how the menu system works.


.SH ENVIRONMENT
.TP
.B  HOME
.I Waimea 
uses this variable to find its
.I .waimearc
file.
.TP
.B DISPLAY
When no other display was given on the command line, 
.I waimea 
will start on the display specified by this variable.


.SH FILES
.TP
.B ~/.waimearc
User configuration file. See
.I "CONFIG FILE"
section for further details.

.TP
.B @pkgdatadir@/config
The system wide configuration file. See
.I "CONFIG FILE"
section for further details.

.TP
.B @pkgdatadir@/style/Default
The system wide style file. See
.I STYLES
section for further details.

.TP
.B @pkgdatadir@/actions/action
The system wide action file. See
.I ACTIONS
section for further details.

.TP
.B @pkgdatadir@/menu
The system wide menu file. See
.I MENUS
section for further details.


.SH BUGS
Bug reports, patches and suggestions are much appreciated,
send them to the author.
.SH AUTHOR
David Reveman <c99drn@cs.umu.se>

The Waimea website:
.nh
.B http://waimea.sourceforge.net
.ny
.SH "SEE ALSO"
.BR blackbox (1), 
.BR X (1)
